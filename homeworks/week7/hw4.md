## 什麼是 DOM？
`DOM`全名 Document Object Model，把瀏覽器底下所有的`tag`都定義成一個物件，並以樹狀結構串聯每個物件。原本是因為每種瀏覽器都會有自己的規則，這樣對於工程師來說，會是很大的負擔，因此在`W3C`出現，並定義許多網頁規則以後，瀏覽器都遵照這些規則，而工程師只要照著做，就不用太擔心在不同瀏覽器的網頁會不同。

在`DOM`架構底下，document、element、text、attribute 都是一個節點。還會因為上下層或是同一層，而有父子母女關係或兄弟姊妹關係，而要抓到網頁指定元素的方法，則會有 querySelector 或是 getElementsBy 等方法，讓工程師可以再對個別元素進行操作。

## 事件傳遞機制的順序是什麼；什麼是冒泡，什麼又是捕獲？
事件總共會有三個階段：捕獲階段 -> target -> 冒泡。
當點擊網頁的任一元素時，點擊的事件會先從 window、document 接著往下傳，一路走到該元素。從 window 走到目標元素的過程，就稱為捕獲階段。
傳遞到元素本身，則稱為 AT-TARGET。
最後事件會從該元素，再一路往上傳，傳回到 document、window，這個階段就被稱作冒泡。

## 什麼是 event delegation，為什麼我們需要它？
事件代理，藉由父節點來處理子節點的事件，這在一個網頁有許多相同元素會很好用。例如作業三的 todo list，如果在每個增減的清單物件上放 listener，等於創造幾個待辦事項，就要搭上幾個 listener，這件事情是滿沒有效率又浪費資源的作法。而我們把 listener 放到整個待辦事項上層的清單上面，藉由上一題提到的事件傳遞機制，清單就能抓到是底下哪一個物件被點取，進而進行打勾或刪除的動作。

## event.preventDefault() 跟 event.stopPropagation() 差在哪裡，可以舉個範例嗎？
`event.preventDefault()`：取消瀏覽器對該元素的預設行為，但事件傳遞不會影響，因為兩者一點關係也沒有。就像作業 1 的表單驗證，在點下送出的按鈕之後，chrome 的預設動作是會重新整理網頁，並把所有填的格子清空。
`event.stopPropagation()`：事件不會再傳遞下去，只到這個元素為止，後續的捕獲、冒泡就都不會做。假設 list 底下有一個超連結 a，但我們在 list 放了`event.stopPropagation()`，那超連結那邊的 listener 就不會接收到事件，進而無法執行我們放在超連結的 listener 的程式。
